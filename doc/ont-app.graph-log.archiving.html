<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>ont-app.graph-log.archiving documentation</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name"></span> <span class="project-version"></span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1 "><a href="intro.html"><div class="inner"><span>Introduction to graph-log</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>ont-app</span></div></div></li><li class="depth-2"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>graph-log</span></div></div></li><li class="depth-3 branch current"><a href="ont-app.graph-log.archiving.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>archiving</span></div></a></li><li class="depth-3 branch"><a href="ont-app.graph-log.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-3 branch"><a href="ont-app.graph-log.levels.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>levels</span></div></a></li><li class="depth-3"><a href="ont-app.graph-log.ont.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>ont</span></div></a></li></ul></div><div class="sidebar secondary"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="ont-app.graph-log.archiving.html#var-.3E.3Elog-is-archived.3E.3E"><div class="inner"><span>&gt;&gt;log-is-archived&gt;&gt;</span></div></a></li><li class="depth-1"><a href="ont-app.graph-log.archiving.html#var-.3E.3Elog-is-resetting.3E.3E"><div class="inner"><span>&gt;&gt;log-is-resetting&gt;&gt;</span></div></a></li><li class="depth-1"><a href="ont-app.graph-log.archiving.html#var-archive-path"><div class="inner"><span>archive-path</span></div></a></li><li class="depth-1"><a href="ont-app.graph-log.archiving.html#var-archive-to-file"><div class="inner"><span>archive-to-file</span></div></a></li><li class="depth-1"><a href="ont-app.graph-log.archiving.html#var-check-archiving.21"><div class="inner"><span>check-archiving!</span></div></a></li><li class="depth-1"><a href="ont-app.graph-log.archiving.html#var-check-archiving-timeout"><div class="inner"><span>check-archiving-timeout</span></div></a></li><li class="depth-1"><a href="ont-app.graph-log.archiving.html#var-def-listener"><div class="inner"><span>def-listener</span></div></a></li><li class="depth-1"><a href="ont-app.graph-log.archiving.html#var-default-archive-path"><div class="inner"><span>default-archive-path</span></div></a></li><li class="depth-1"><a href="ont-app.graph-log.archiving.html#var-log-reset.21"><div class="inner"><span>log-reset!</span></div></a></li><li class="depth-1"><a href="ont-app.graph-log.archiving.html#var-save-to-archive.21"><div class="inner"><span>save-to-archive!</span></div></a></li><li class="depth-1"><a href="ont-app.graph-log.archiving.html#var-set-continuing-from.21"><div class="inner"><span>set-continuing-from!</span></div></a></li><li class="depth-1"><a href="ont-app.graph-log.archiving.html#var-tap-listeners.3F"><div class="inner"><span>tap-listeners?</span></div></a></li><li class="depth-1"><a href="ont-app.graph-log.archiving.html#var-the"><div class="inner"><span>the</span></div></a></li><li class="depth-1"><a href="ont-app.graph-log.archiving.html#var-wait-for"><div class="inner"><span>wait-for</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h1 class="anchor" id="top">ont-app.graph-log.archiving</h1><div class="doc"><pre class="plaintext">Adds logic to archive the contents of log graphs on reset.
</pre></div><div class="public anchor" id="var-.3E.3Elog-is-archived.3E.3E"><h3>&gt;&gt;log-is-archived&gt;&gt;</h3><div class="usage"></div><div class="doc"><pre class="plaintext">A channel containing a series of `archive-state`s  reflecting the fact that the old log has been archived and a new one has been declared.
Typically handlers of this channel will call `set-continuing-from!` on each
`archive-state` to link the new log-graph back to the archive of the previous graph.
Where
- `set-continuing-from!` := fn [archive-state] -&gt; ? with side-effect of setting
  (@glog/log-graph :glog/LogGraph  :glog/continuingFrom) to `volume`
- `archive-state` := {::volume ..., ...}
- `volume` is the file holding an edn representation of the previous
  incarnation of @glog/log-graph.
</pre></div></div><div class="public anchor" id="var-.3E.3Elog-is-resetting.3E.3E"><h3>&gt;&gt;log-is-resetting&gt;&gt;</h3><div class="usage"></div><div class="doc"><pre class="plaintext">A channel which will call its handler (set in `def-listener`) on each `reset-state`
Where
`handler` := fn [reset-state] -&gt; ? with side-effect of archving `old-graph`
`reset-state` :=  {:old-graph ..., :new-graph ..., ...}
`old-graph` is the old log-graph being reset to `new-graph`
</pre></div></div><div class="public anchor" id="var-archive-path"><h3>archive-path</h3><div class="usage"><code>(archive-path g)</code></div><div class="doc"><pre class="plaintext">Returns a canonical name for an archive file for a log, caluclated per `archive-path-fn` derived from `g`
Where
- `g` is a log-graph, Typically `glog:LogGraph`
- `archive-path-fn` := [g] -&gt; `archive-path`. Or `default-archive-path`

VOCABULARY:
- &lt;log-graph&gt; `:glog/archivePathFn` &lt;fn kw&gt;
- &lt;log-graph&gt; `:glog/timestamp` &lt;timestamp&gt;
- &lt;log-graph&gt; `:glog/archiveDirectory` &lt;directory URL&gt;
- &lt;fn kw&gt; `:igraph/compiledAs`  &lt;fn [g] -&gt; archive-path&gt;
</pre></div></div><div class="public anchor" id="var-archive-to-file"><h3>archive-to-file</h3><div class="usage"><code>(archive-to-file reset-state)</code></div><div class="doc"><pre class="plaintext">Side-effects: writes `contents` inferred from `reset-state` to `archive-file` and posts `archive-state` to `&gt;&gt;log-is-archived&gt;&gt;`.
Where
- `contents` is `old-graph` minus `new-graph`, and anything that would choke a 
 reader, rendered in EDN.
- `reset-state` := {::topic  ::log-reset
                ::`old-graph` ... 
                ::`new-graph` ...
                }
- `archive-state` := {::topic ::archive-state
                     ::volume `archive-file`,
                     ...}, merged with `reset-state`.
- `old-graph` is the previous contents of a log-graph
- `new-graph` is the newly reset log-graph
- `archive-file` is the path to a the `contents` written to disk.
</pre></div></div><div class="public anchor" id="var-check-archiving.21"><h3>check-archiving!</h3><div class="usage"><code>(check-archiving!)</code><code>(check-archiving! ms)</code><code>(check-archiving! gatom ms)</code></div><div class="doc"><pre class="plaintext">Side-effect: sets the :glog/continuingFrom relation in `gatom`
Where
- `gatom` is an atom containing an IGraph, (default `log-graph`),
  it must be configured so as to enable archiving.
- `ms` is a timeout in milliseconds
- `archive-state` := {:glog/continuingFrom `url`, ...}
- `url` is typically the URL of the contents of the previous `gatom`,
  before the most recent call to `log-reset!`.

VOCABULARY:
- `:glog/LogGraph` - identifies the log graph itself in @log-graph
- `:glog/FreshArchive` - names type for LogGraph with 0 iterations
- `&lt;log-graph&gt; `:glog/iteration` &lt;# of times graph has been reset&gt;
- `&lt;log-graph&gt; `:glog/continuingFrom` &lt;url of previous archived log iteration&gt;</pre></div></div><div class="public anchor" id="var-check-archiving-timeout"><h3>check-archiving-timeout</h3><div class="usage"></div><div class="doc"><pre class="plaintext">The timeout in ms for the `check-archiving!` function. Default is 1000
</pre></div></div><div class="public anchor" id="var-def-listener"><h3>def-listener</h3><h4 class="type">macro</h4><div class="usage"><code>(def-listener channel handler)</code></div><div class="doc"><pre class="plaintext">Expands to a go-loop which Binds to a `channel` a `handler`
Where
- `channel` is an async port
- `handler` := [article] -&gt; ?, typically with the side-effect of archiving `article`
- `article` is an item read from `channel` asynchronously. Typically in a format
  specific to `channel`.
</pre></div></div><div class="public anchor" id="var-default-archive-path"><h3>default-archive-path</h3><div class="usage"><code>(default-archive-path g)</code></div><div class="doc"><pre class="plaintext">Returns rendering of `{{directory}}/{{start}}-{{stop}}.edn`
Where
- `directory` is (g :glog/LogGraph :glog/archiveDirectory) or /tmp
- `start` is the timestamp of the 0th entry
- `stop` is the timestamp of the nth entry

VOCABULARY
- &lt;graph-log&gt; `:glog/archiveDirectory` `directory` (optional; default /tmp)
- &lt;log entry&gt; `:glog/timestamp` &lt;epoch ms&gt;
</pre></div></div><div class="public anchor" id="var-log-reset.21"><h3>log-reset!</h3><div class="usage"><code>(log-reset!)</code><code>(log-reset! new-graph)</code></div><div class="doc"><pre class="plaintext">Side-effect: resets @log-graph to `new-graph`
Side-effect: if (initial-graph:glog/ArchivePathFn igraph/compiledAs &lt;path-fn&gt;),
  the previous contents of the graph will be spit'd to &lt;output-path&gt;
Where
- &lt;initial-graph&gt; is an IGraph, informed by ont-app.graph-log.core/ontology
- &lt;path-fn&gt; := fn [g] -&gt; &lt;output-path&gt;
- &lt;output-path&gt; is a valid path specification , possibly starting with file://

VOCABULARY
- `:glog/LogGraph` - identifies the log graph itself in @log-graph
- &lt;log-graph&gt; `:glog/iteration` &lt;# of times graph has been reset&gt;
- &lt;log-graph&gt; `:glog/archivePathFn` &lt;fn kw&gt;
- &lt;fn kw&gt; `:igraph/compiledAs` &lt;fn [g] -&gt; archive path&gt;
</pre></div></div><div class="public anchor" id="var-save-to-archive.21"><h3>save-to-archive!</h3><div class="usage"><code>(save-to-archive! archive-path g)</code></div><div class="doc"><pre class="plaintext">Side-effect: Writes contents of `g` to `archive-path`, after removing stuff that would choke a reader.
Returns `archive-path` for `g`
Where:
- `g` is a graph derived from a log-graph
- `archive-path` is a path to which the contents of `g` are written, generated 
  by (`archive-path-fn` `g`)
- `archive-path-fn` is a compiled function asserted with `:glog/archivePathFn`, 
   or the default function `archive-path`.

  VOCABULARY
  - &lt;log-graph&gt; `:glog/archivePathFn` &lt;fn kw&gt;
  - &lt;fn kw&gt; `:igraph/compiledA`s &lt;fn&gt;</pre></div></div><div class="public anchor" id="var-set-continuing-from.21"><h3>set-continuing-from!</h3><div class="usage"><code>(set-continuing-from! archive-state)</code></div><div class="doc"><pre class="plaintext">Side-effect: establishes :glog/coninuingFrom in value per `archive-state` in `gatom`
Where
  - `archive-state` := {::volume `url`, ...}
  - `gatom` (optional) an atom containing an IGraph. Default is log-graph
  - `url` is the URL of a location where the previous contents of @log-graph
     have been archived. 
  - Note: may throw error of type ::UnexpectedArchivingResult.

  VOCABULARY:
  - `:glog/LogGraph`
  - &lt;log-graph&gt; `:glog/continuingFrom` `url`</pre></div></div><div class="public anchor" id="var-tap-listeners.3F"><h3>tap-listeners?</h3><div class="usage"></div><div class="doc"><pre class="plaintext">Set to `true` when you want to tap&gt; each article when it comes off a listener channel.
</pre></div></div><div class="public anchor" id="var-the"><h3>the</h3><div class="usage"></div><div class="doc"><pre class="plaintext">alias for igraph/unique
</pre></div></div><div class="public anchor" id="var-wait-for"><h3>wait-for</h3><div class="usage"><code>(wait-for the-test ms)</code></div><div class="doc"><pre class="plaintext">Returns: non-falsey `result` of `test`, or ::timeout after `ms` milliseconds. 
Where
- `result` is a truthy response from `test`
- `the-test` := fn [] -&gt; truthy value
- `ms` is max time to wait for `test` to be truthy
</pre></div></div></div></body></html>